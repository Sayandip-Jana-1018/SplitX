'use client';

import { formatCurrency } from '@/lib/utils';

interface ExportMember {
    name: string;
}

interface ExportTransaction {
    title: string;
    amount: number;   // paise
    payer: string;
    category: string;
    method: string;
    date: Date;
}

interface ExportSettlement {
    from: string;
    to: string;
    amount: number; // paise
}

export interface ExportData {
    groupName: string;
    tripName: string;
    members: ExportMember[];
    transactions: ExportTransaction[];
    settlements: ExportSettlement[];
    totalSpent: number;
    exportDate: Date;
}

/**
 * Generate a text-based settlement summary for sharing
 */
export function generateTextSummary(data: ExportData): string {
    const lines: string[] = [];

    lines.push(`â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    lines.push(`  SplitX â€” Settlement Summary`);
    lines.push(`â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•`);
    lines.push('');
    lines.push(`ðŸ“‹ Trip: ${data.tripName}`);
    lines.push(`ðŸ‘¥ Group: ${data.groupName}`);
    lines.push(`ðŸ‘¤ Members: ${data.members.map((m) => m.name).join(', ')}`);
    lines.push(`ðŸ’° Total Spent: ${formatCurrency(data.totalSpent)}`);
    lines.push(`ðŸ“… Exported: ${data.exportDate.toLocaleDateString('en-IN', { day: 'numeric', month: 'short', year: 'numeric' })}`);
    lines.push('');

    // Transaction list
    lines.push(`â”€â”€ Transactions (${data.transactions.length}) â”€â”€`);
    data.transactions.forEach((t, i) => {
        lines.push(`  ${i + 1}. ${t.title}`);
        lines.push(`     ${formatCurrency(t.amount)} â€¢ Paid by ${t.payer} â€¢ ${t.category} â€¢ ${t.method}`);
    });
    lines.push('');

    // Settlements
    lines.push(`â”€â”€ Settlements â”€â”€`);
    if (data.settlements.length === 0) {
        lines.push(`  âœ… All settled up!`);
    } else {
        data.settlements.forEach((s) => {
            lines.push(`  ðŸ’¸ ${s.from} â†’ ${s.to}: ${formatCurrency(s.amount)}`);
        });
    }
    lines.push('');
    lines.push(`â”€â”€ Generated by SplitX â”€â”€`);

    return lines.join('\n');
}

/**
 * Generate a CSV export of transactions
 */
export function generateCSV(data: ExportData): string {
    const headers = ['#', 'Title', 'Amount', 'Paid By', 'Category', 'Method', 'Date'];
    const rows = data.transactions.map((t, i) => [
        i + 1,
        `"${t.title}"`,
        (t.amount / 100).toFixed(2),
        `"${t.payer}"`,
        t.category,
        t.method,
        t.date.toISOString().split('T')[0],
    ]);

    return [
        headers.join(','),
        ...rows.map((r) => r.join(',')),
        '',
        '# Settlements',
        'From,To,Amount',
        ...data.settlements.map((s) => `"${s.from}","${s.to}",${(s.amount / 100).toFixed(2)}`),
    ].join('\n');
}

/**
 * Download a file from text content
 */
export function downloadFile(content: string, filename: string, mimeType: string) {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

/**
 * Export as plain text
 */
export function exportAsText(data: ExportData) {
    const text = generateTextSummary(data);
    downloadFile(text, `${data.tripName}_settlement.txt`, 'text/plain');
}

/**
 * Export as CSV
 */
export function exportAsCSV(data: ExportData) {
    const csv = generateCSV(data);
    downloadFile(csv, `${data.tripName}_transactions.csv`, 'text/csv');
}

/**
 * Share via Web Share API (mobile)
 */
export async function shareSettlement(data: ExportData): Promise<boolean> {
    const text = generateTextSummary(data);

    if (navigator.share) {
        try {
            await navigator.share({
                title: `${data.tripName} â€” Settlement Summary`,
                text,
            });
            return true;
        } catch {
            return false;
        }
    }

    // Fallback: copy to clipboard
    try {
        await navigator.clipboard.writeText(text);
        return true;
    } catch {
        return false;
    }
}
